Project Euler #29: Distinct powers:
This problem is a programming version of Problem 29 from projecteuler.net

Consider all integer combinations a^b of 2<=a<=5  for  2<=b<=5 and :
2^2=4 2^3=8 2^4=16 2^5=32
3^2=9 3^3=27 3^4=81 3^5=243
4^2=16 4^3=64 4^4=256 4^5=1024
5^2=25 5^3=125 5^4=625 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
  4,8,9,16,25,27,32,64,81,125,243,256,625,1024,3125
How many distinct terms are in the sequence generated by a^b for 2<=a<=N  and 2<=b<=N ?

Input Format

Input contains an integer N

Constraints
2<=N<=10^5

Output Format

Print the answer corresponding to the test case.
Sample Input

5
Sample Output

15

first:
make every element group by base, and count them, record in arr;
second:
insert to a hash set by 1->count with 2-> N  for every base;

for example N = 100:
base 2: include 2 4 8 16 32 64 (count = 6)
bass 3: include 3 9 27 81  (count =4)
base 4 skip include in base 2;
base 5: include 5 25 (count =2)
base 6: include 6 36 (count =2)
base 7 include 7 49 (count =2)
base 8 skip
base 9: skip
base 10 include 10 100 (count =2)
base 11 count =1
...
base 99 count=1
base 100 skip

deferent base has defferent powers:
same base may has some overlap cases, 
only relate to the count and exponent number, 
use unordered_set to record number, and count successful insert;
and make map for every count case for the other base,
cause different base has same count number share the same numbers of distinct powers.
  
sulotion:
time cost(O(n*logn)), space cost(O(nlogn));

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n;
    cin>>n;
    unordered_set<int>basepw;
    vector<int>vvi;
    for(long i =2; i <=n;i++){
        if(!basepw.insert(i).second)continue;
        int vit=1;
        long j = i*i;
        while(j<=n){
            vit++;
            basepw.insert(j);
            j*=i;
        }
        vvi.push_back(vit);
    }
    long res = n-1;
    unordered_map<int,int>mp;
    for(auto vit:vvi){
        if(mp.count(vit)){
            res += mp[vit];
        }else{
            //only the first time come here, after that, all case has record in mp;
            basepw.clear();
            mp[1] = res;
            for(int pw = 2; pw<=vit; pw++){
                for(int j = (n+pw)/pw;j<=n;j++){
                    if(basepw.insert(pw*j).second){
                        res++;
                    }
                }
                mp[pw]=res;
            }
        }
    }
    cout<<res<<endl;
    return 0;
}

